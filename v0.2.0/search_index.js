var documenterSearchIndex = {"docs":
[{"location":"api/#Anime-API","page":"Anime API","title":"Anime API","text":"","category":"section"},{"location":"api/#Contents","page":"Anime API","title":"Contents","text":"","category":"section"},{"location":"api/","page":"Anime API","title":"Anime API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Index","page":"Anime API","title":"Index","text":"","category":"section"},{"location":"api/","page":"Anime API","title":"Anime API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/","page":"Anime API","title":"Anime API","text":"Modules = [Anime]","category":"page"},{"location":"api/#Anime.Anime","page":"Anime API","title":"Anime.Anime","text":"Anime: Atmospheric aNd Instrumental Models in the Measurement Equation\n\n\n\n\n\n","category":"module"},{"location":"api/#Anime.addweightcols-Tuple{String, String, Bool, Bool}","page":"Anime API","title":"Anime.addweightcols","text":"addweightcols(msname::String, mode::String, sigmaspec::Bool, weightspec::Bool)\n\nAdd WEIGHTSPECTRUM and SIGMASPECTRUM columns to the MS\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.attenuate-Tuple{CjlObservation, Array{Float64, 3}}","page":"Anime API","title":"Anime.attenuate","text":"attenuate(obs::CjlObservation, transmission::Array{Float64, 3})\n\nCompute attenuation due to troposphere\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.bandpass-Tuple{String, Array{ComplexF32, 4}, DataFrames.DataFrame, Random.AbstractRNG, Vector{Int32}, Vector{Int32}, Int64, Vector{Float64}}","page":"Anime API","title":"Anime.bandpass","text":"bandpass(bandpassfile::String, data::Array{Complex{Float32},4}, stationinfo::DataFrame, rngcorrupt::AbstractRNG,\nantenna1::Vector{Int32}, antenna2::Vector{Int32}, numchan::Int64, chanfreqvec::Vector{Float64}; h5file::String=\"\")\n\nCompute the bandpass model and apply to data. The actual numerical values are serialized as HDF5.\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.compute_meandelays-Tuple{CjlObservation, DataFrames.DataFrame, Matrix{Float64}, HDF5.Group}","page":"Anime API","title":"Anime.compute_meandelays","text":"compute_meandelays(obs::CjlObservation, atmdf::DataFrame, elevationmatrix::Array{Float64, 2}, g::HDF5.Group)\n\nCompute mean delays\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.compute_skynoise-Tuple{CjlObservation, DataFrames.DataFrame, Array{Float64, 3}, HDF5.Group}","page":"Anime API","title":"Anime.compute_skynoise","text":"compute_skynoise(obs::CjlObservation, atmdf::DataFrame, transmission::Array{Float64, 3}, g::HDF5.Group)\n\nCompute sky noise contribution\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.compute_turbulence-Tuple{CjlObservation, DataFrames.DataFrame, Matrix{Float64}, HDF5.Group}","page":"Anime API","title":"Anime.compute_turbulence","text":"compute_turbulence(obs::CjlObservation, atmdf::DataFrame, elevationmatrix::Array{Float64, 2}, g::HDF5.Group)\n\nCompute turbulent phases\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.computeweights!-Tuple{Array{Float32, 4}, Array{Float32, 4}, CjlObservation}","page":"Anime API","title":"Anime.computeweights!","text":"computeweights!(totalrmsspec::Array{Float32, 4}, totalwtspec::Array{Float32, 4}, obs::CjlObservation; h5file::String=\"\")\n\nCompute total rms (sigma) values from independent noise sources\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.elevationangle-Tuple{Vector{Float64}, Matrix{Float64}, DataFrames.DataFrame, Matrix{Float64}}","page":"Anime API","title":"Anime.elevationangle","text":"elevationangle(times::Vector{Float64}, phasedir::Array{Float64,2}, stationinfo::DataFrame, pos::Array{Float64, 2})\n\nCompute elevation angle for all stations for all times.\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.gentimeseries!-Tuple{Vector{ComplexF32}, String, ComplexF32, Float32, Float32, Int64, Random.AbstractRNG}","page":"Anime API","title":"Anime.gentimeseries!","text":"gentimeseries!(series::Vector{ComplexF32}, mode::String, location::ComplexF32, scale::Float32, driftrate::Float32, nsamples::Int64, rng::AbstractRNG)\n\nGenerate a complex-valued Gaussian process time-series of length nsamples with the given location, scale, and driftrate parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.gentimeseries!-Tuple{Vector{Float32}, String, Float32, Float32, Float32, Int64, Random.AbstractRNG}","page":"Anime API","title":"Anime.gentimeseries!","text":"gentimeseries!(series::Vector{Float32}, mode::String, location::Float32, scale::Float32, driftrate::Float32, nsamples::Int64, rng::AbstractRNG)\n\nGenerate a complex-valued Gaussian process time-series of length nsamples with the given location, scale, and driftrate parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.gentimeseries!-Tuple{Vector{Float64}, String, Float64, Float64, Float64, Int64, Random.AbstractRNG}","page":"Anime API","title":"Anime.gentimeseries!","text":"gentimeseries!(series::Vector{Float64}, mode::String, location::Float64, scale::Float64, driftrate::Float64, nsamples::Int64, rng::AbstractRNG)\n\nGenerate a complex-valued Gaussian process time-series of length nsamples with the given location, scale, and driftrate parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.instrumentalpol-Tuple{Vector{Int32}, Vector{Float64}, DataFrames.DataFrame, Matrix{Float64}, Matrix{Float64}, Array{ComplexF32, 4}, Int64, String, String, Vector{Int32}, Vector{Int32}, Float64, Random.AbstractRNG}","page":"Anime API","title":"Anime.instrumentalpol","text":"instrumentalpol(scanno::Vector{Int32}, times::Vector{Float64}, stationinfo::DataFrame, phasedir::Array{Float64,2},\npos::Array{Float64, 2}, data::Array{Complex{Float32},4}, numchan::Int64, polframe::String, polmode::String,\nantenna1::Vector{Int32}, antenna2::Vector{Int32}, exposure::Float64, rngcorrupt::AbstractRNG; h5file::String=\"\")\n\nCompute instrumental polarization (leakage, or \"D-Jones\" terms) and apply to data. The actual numerical values are serialized as HDF5.\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.loadms-Tuple{String, String, Int64, Int64, Bool, Float64, Bool, Bool, Bool, Bool, String, String, Float64, String, String, String}","page":"Anime API","title":"Anime.loadms","text":"loadms(msname::String, stations::String, corruptseed::Int64, tropseed::Int64, tropwetonly::Bool, correff::Float64, tropattenuate::Bool,\ntropskynoise::Bool, tropmeandelays::Bool, tropturbulence::Bool, polframe::String, polmode::String, ptginterval::Float64, ptgmode::String,\nstationgainsmode::String, bandpassfile::String; delim::String=\",\", ignorerepeated::Bool=false)\n\nLoad data and metadata from MS and station table and return a CjlObservation object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.makecasaanttable-Tuple{String, String}","page":"Anime API","title":"Anime.makecasaanttable","text":"makecasaanttable(stations::String, casaanttemplate::String; delim::String=\",\", ignorerepeated::Bool=false)\n\nGenerate a CASA antenna table from CSV station info file in the current working directory.\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.msfromconfig-Tuple{String, String, String, String, Vector{Float64}, Vector{Float64}, Vector{Int64}, Dict{String, Any}, String, Float64, Int64, Vector{Float64}, Float64}","page":"Anime API","title":"Anime.msfromconfig","text":"msfromconfig(msname::String, mscreationmode::String, stations::String, casaanttemplate::String, spw_centrefreq::Array{Float64, 1}, \nspw_bw::Array{Float64, 1}, spw_channels::Array{Int64, 1}, sourcedict::Dict{String, Any}, starttime::String, exposure::Float64, scans::Int64,\nscanlengths::Array{Float64, 1}, scanlag::Float64; autocorr::Bool=false, telescopename::String=\"VLBA\", feed::String=\"perfect R L\",\nshadowlimit::Float64=1e-6, elevationlimit::String=\"10deg\", stokes::String=\"RR RL LR LL\", delim::String=\",\", ignorerepeated::Bool=false)\n\nGenerate measurement set from scratch from input observation parameters\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.msfromuvfits-NTuple{4, String}","page":"Anime API","title":"Anime.msfromuvfits","text":"msfromuvfits(uvfits::String, msname::String, mscreationmode::String, stations::String; delim::String=\",\", ignorerepeated::Bool=false)\n\nGenerate MS from existing UVFITS file\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.msfromvex-Tuple{}","page":"Anime API","title":"Anime.msfromvex","text":"msfromvex()\n\nExtract config parameters from VEX schedule and call msfromconfig() to generate MS\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.parallacticangle-Tuple{Vector{Float64}, Matrix{Float64}, DataFrames.DataFrame, Matrix{Float64}}","page":"Anime API","title":"Anime.parallacticangle","text":"parallacticangle(times::Vector{Float64}, phasedir::Array{Float64,2}, stationinfo::DataFrame, pos::Array{Float64,2})\n\nCompute parallactic angle for all stations for all times.\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.plotbandpass-Tuple{String, Vector{InlineStrings.String3}, Vector{Float64}}","page":"Anime API","title":"Anime.plotbandpass","text":"plotbandpass(h5file::String, stationnames::Vector{String3}, chanfreqvec::Vector{Float64}; saveas=\"bandpassgains.png\")\n\nPlot bandpass gains against time\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.plotpointingerrors-Tuple{String, Vector{Int32}, Vector{InlineStrings.String3}}","page":"Anime API","title":"Anime.plotpointingerrors","text":"plotpointingerrors(h5file::String, scanno::Vector{Int32}, stationnames::Vector{String3})\n\nPlot pointing errors\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.plotstationgains-Tuple{String, Vector{Int32}, Vector{Float64}, Vector{InlineStrings.String3}}","page":"Anime API","title":"Anime.plotstationgains","text":"plotstationgains(h5file::String, scanno::Vector{Int32}, times::Vector{Float64}, stationnames::Vector{String3}; saveas=\"stationgainsvstime.png\")\n\nPlot station gains against time\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.plotvis-Tuple{Matrix{Float64}, Vector{Float64}, Array{Bool, 4}, Array{ComplexF32, 4}, Int64, Vector{Float64}}","page":"Anime API","title":"Anime.plotvis","text":"plotvis(uvw::Matrix{Float64}, chanfreqvec::Array{Float64,1}, flag::Array{Bool,4}, data::Array{Complex{Float32},4},\nnumchan::Int64, times::Vector{Float64}; saveprefix=\"data_\")\n\nGenerate various complex visibility plots\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.pointing-Tuple{DataFrames.DataFrame, Vector{Int32}, Vector{Float64}, Float64, String, Float64, Vector{Float64}, Random.AbstractRNG, Vector{Int32}, Vector{Int32}, Array{ComplexF32, 4}, Int64}","page":"Anime API","title":"Anime.pointing","text":"pointing(stationinfo::DataFrame, scanno::Vector{Int32}, chanfreqvec::Vector{Float64}, ptgint::Float64, ptgmode::String,\nexposure::Float64, times::Vector{Float64}, rngcorrupt::AbstractRNG, antenna1::Vector{Int32}, antenna2::Vector{Int32},\ndata::Array{Complex{Float32},4}, numchan::Int64; h5file::String=\"\")\n\nCompute the pointing model and apply to data. The actual numerical values are serialized as HDF5.\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.postprocessms-Tuple{CjlObservation}","page":"Anime API","title":"Anime.postprocessms","text":"postprocessms(obs::CjlObservation; h5file::String=\"\")\n\nAdd weights and sigma matrices, update data matrix, reshape them all and write to MS\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.run_wsclean-Tuple{String, String, Bool, Int64, Int64}","page":"Anime API","title":"Anime.run_wsclean","text":"run_wsclean(msname::String, fitsdir::String, polarized::Bool, channelgroups::Int64, osfactor::Int64)\n\nCompute source coherency using WSClean\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.setup_polarization-Tuple{String, String}","page":"Anime API","title":"Anime.setup_polarization","text":"setup_polarization(msname::String, stationtable::String)\n\nSet up all polarization subtables in the MS based on the station feed types\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.stationgains-Tuple{Vector{Int32}, Vector{Float64}, Float64, Array{ComplexF32, 4}, DataFrames.DataFrame, String, Random.AbstractRNG, Vector{Int32}, Vector{Int32}, Int64}","page":"Anime API","title":"Anime.stationgains","text":"stationgains(scanno::Vector{Int32}, times::Vector{Float64}, exposure::Float64, data::Array{Complex{Float32},4},\nstationinfo::DataFrame, mode::String, rngcorrupt::AbstractRNG, antenna1::Vector{Int32}, antenna2::Vector{Int32}, numchan::Int64; h5file::String=\"\")\n\nCompute time-variable station gains and apply to data. The actual numerical values are serialized as HDF5.\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.thermalnoise-Tuple{Vector{Float64}, Vector{Int32}, Vector{Int32}, Array{ComplexF32, 4}, Float64, Float64, Float64, Random.AbstractRNG, Vector{Float64}}","page":"Anime API","title":"Anime.thermalnoise","text":"thermalnoise(times::Vector{Float64}, antenna1::Vector{Int32}, antenna2::Vector{Int32}, data::Array{Complex{Float32},4}, correff::Float64,\nexposure::Float64, chanwidth::Float64, rngcorrupt::AbstractRNG, sefd::Vector{Float64}; h5file::String=\"\")\n\nCompute per-baseline thermal noise in visibility domain and apply to data. The actual numerical values are serialized as HDF5.\n\n\n\n\n\n","category":"method"},{"location":"api/#Anime.troposphere-Tuple{CjlObservation}","page":"Anime API","title":"Anime.troposphere","text":"troposphere(obs::CjlObservation; h5file::String=\"\")\n\nCompute various tropospheric effects and apply to data. The actual numerical values are serialized as HDF5.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Example-Anime-Workflow","page":"Example Anime Workflow","title":"Example Anime Workflow","text":"","category":"section"},{"location":"examples/","page":"Example Anime Workflow","title":"Example Anime Workflow","text":"Anime takes pre-generated source models and some basic information about weather conditions and the dishes on-site at each station as inputs.","category":"page"},{"location":"insmodelling/#Instrument-Modelling-and-Synthetic-Data-Generation","page":"Instrument Modelling and Synthetic Data Generation","title":"Instrument Modelling and Synthetic Data Generation","text":"","category":"section"},{"location":"insmodelling/","page":"Instrument Modelling and Synthetic Data Generation","title":"Instrument Modelling and Synthetic Data Generation","text":"Very Long Baseline Interferometry (VLBI) enables the highest angular resolution achievable in astronomy, up to ~20 Î¼as in the case of the Event Horizon Telescope (EHT) that produced the first ever images of a black hole in 2019. Since VLBI uses a sparse, heterogeneous array of radio telescopes located around the world, reconstructing images of observed astronomical sources is an ill-posed problem, and a deeper understanding of not only the astronomical source of interest but the instrument itself becomes crucial.","category":"page"},{"location":"insmodelling/","page":"Instrument Modelling and Synthetic Data Generation","title":"Instrument Modelling and Synthetic Data Generation","text":"Detailed modelling of the instrument from first principles enables us to understand the capabilities and limitations of any VLBI array. Synthetic observations which realistically represent the underlying physics that give rise to the observed data are necessary to understand the characteristics of an instrument, develop new algorithms for data analysis, and perform feasibility studies for future arrays and identify new sites for upgrading existing arrays.","category":"page"},{"location":"insmodelling/#Radio-Interferometer-Measurement-Equation","page":"Instrument Modelling and Synthetic Data Generation","title":"Radio Interferometer Measurement Equation","text":"","category":"section"},{"location":"insmodelling/","page":"Instrument Modelling and Synthetic Data Generation","title":"Instrument Modelling and Synthetic Data Generation","text":"The Radio Interferometer Measurement Equation (RIME)[HBS][OMS] lies at the heart of modelling interferometric observations. A generic discrete RIME can be written as","category":"page"},{"location":"insmodelling/","page":"Instrument Modelling and Synthetic Data Generation","title":"Instrument Modelling and Synthetic Data Generation","text":"mathbfV_pq = G_p left( sum_s E_sp mathbfX_spq E_sq^H right) G_q^H","category":"page"},{"location":"insmodelling/","page":"Instrument Modelling and Synthetic Data Generation","title":"Instrument Modelling and Synthetic Data Generation","text":"where the summation is carried out over all the sources s, and boldsymbolE_sp and boldsymbolG_p denote generic direction-dependent effects (DDEs) and direction-independent effects (DIEs) respectively. Each term is a 2times2 Jones matrix that describes any linear transformation acting on the incoming wave, and H is the Hermitian conjugate.","category":"page"},{"location":"insmodelling/","page":"Instrument Modelling and Synthetic Data Generation","title":"Instrument Modelling and Synthetic Data Generation","text":"More detailed discussion of instrumental models to follow ...","category":"page"},{"location":"insmodelling/#References","page":"Instrument Modelling and Synthetic Data Generation","title":"References","text":"","category":"section"},{"location":"insmodelling/","page":"Instrument Modelling and Synthetic Data Generation","title":"Instrument Modelling and Synthetic Data Generation","text":"[HBS]: Hamaker J.P, Bregman J.D., Sault R.J. (1996) [https://articles.adsabs.harvard.edu/pdf/1996A%26AS..117..137H]  ","category":"page"},{"location":"insmodelling/","page":"Instrument Modelling and Synthetic Data Generation","title":"Instrument Modelling and Synthetic Data Generation","text":"[OMS]: Smirnov O.M (2011) [https://www.aanda.org/articles/aa/pdf/2011/03/aa16082-10.pdf]","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#Pre-requisites","page":"Installation","title":"Pre-requisites","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Anime.jl uses the python package casatools to handle the creation and manipulation of CASA Measurement Sets. If you install Anime.jl using Julia's package manager, casatools will be automatically installed.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Install WSClean for predicting uncorrupted visibilities. On Ubuntu, this can be done via the Ubuntu package manager.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"note: Note\nThe use of WSClean will be deprecated soon as source coherency will be computed internally in Julia instead of relying on external packages.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Install AATM for computing certain atmospheric quantities that affect the observation, such as transmission, dry and wet path lengths, and sky temperature.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"note: Note\nThe use of AATM will be deprecated soon as more advance atmospheric modelling frameworks are integrated into Anime.","category":"page"},{"location":"install/#Installing-Anime","page":"Installation","title":"Installing Anime","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Anime.jl can be installed using Julia's package manager by entering the Julia REPL and typing","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"Anime\")","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"or by entering package mode by typing ] in the Julia REPL and then typing","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"add Anime","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Anime","category":"page"},{"location":"#Anime","page":"Home","title":"Anime","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Atmospheric aNd Instrumental models in the Measurement Equation - Anime - is an instrument modelling framework for radio interferometry written in Julia, an open source, high performance language for scientific computing. Anime aims to support efficient handling of various data formats commonly used in VLBI, provide seamless conversion between these formats and a variety of data products as output by a Very Long Baseline Interferometry (VLBI) array, and integrate with other Julia-based calibration and Bayesian VLBI imaging software packages such as Comrade.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"install.md\",\n    \"insmodelling.md\",\n    \"examples.md\"\n    \"api.md\"\n]","category":"page"}]
}
