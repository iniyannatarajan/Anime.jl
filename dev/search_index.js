var documenterSearchIndex = {"docs":
[{"location":"components/#Components","page":"Components","title":"Components","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"Anime can be run in two modes: imported as a module with callable functions or as a single pipeline that accepts input settings in YAML and CSV files and runs without human intervention. The following diagram gives an overview of the design.","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"(Image: Design overview)","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"Anime loads the metadata of the VLBI observation and the observed data into a Structure-of-Arrays (SoA) in-memory representation with which all the functions that compute instrument models are expected to interface. The generated models (also referred to as gain tables) are written out to an HDF5 file. The functionality within the dotted boxes are not considered essential to the generation of instrument models, but are provided for completion. These include","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"generation of an MS from scratch,\ncomputing and writing source coherency to MS, and\napplying instrument models to data and writing them back to the MS.","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"In modular mode, any calibration or imaging software can call any function in the box \"Compute instrument model\" and process the gain tables as they see fit. In pipeline mode, the entire control flow is automated by using a YAML file as shown below.","category":"page"},{"location":"components/#Input-files","page":"Components","title":"Input files","text":"","category":"section"},{"location":"components/#Observation-parameters","page":"Components","title":"Observation parameters","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"Functions such as msfromconfig require the user to input various arguments that define the parameters of observation. For ease of use, these parameters can be collected in a YAML file which can be passed directly to Anime in pipeline mode.","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"####################################################\n# sample config file for AnimeDriver.jl\n####################################################\n# settings to generate a new ms\n\nmode: \"manual\"                                       # \"uvfits\" and \"manual\" are the only allowed values\nmsname: \"eht.ms\"                                  # name of output ms \ntelescopename: \"VLBA\"                                # preset telescope known to casa (not important since CASA is not used for predict; just an argument required for setconfig)\nstations: \"inputs/eht_2017.stations\"     # CSV file with station parameters\ncasaanttemplate: \"inputs/antenna_table.template\"                 # Input CASA ANTENNA table to use as template\nvex: \"inputs/vexfiles/e17e11.vex\"    # name of the VEX schedule to use for observing\nuvfits: \"inputs/vfitsfiles/hops_lo_3601_M87+zbl-dtcal_selfcal.uvfits\" # name of uvfits file to convert to ms\nautocorr: false                                      # toggle whether to include autocorrelations\nfeed: \"perfect R L\"                                  # \"perfect R L\" or \"perfect X Y\"\nshadowlimit: 1e-6                                    # maximum fraction of geometrically shadowed area before flagging occurs\nelevationlimit: \"10deg\"                              # minimum elevation angle before flagging occurs\nsource:\n  M87:\n    RA: \"12h30m49.42\"                                # right ascension of source position in hours\n    Dec: \"+12.23.28.04\"                              # declination of source position in degrees\n    epoch: \"J2000\"                                   # \"J2000\" or \"B1950\"\nscans: 5                                             # number of scans\nscanlengths: [600.0, 600.0, 600.0, 600.0, 600.0]                              # list of lengths of each scan in seconds\nscanlag: 180.0                                     # lag time between scans in seconds\nexposure: 0.4                                          # integration time in seconds\nstokes: \"RR RL LR LL\"                                # CASA understandable Stokes types to simulate (check official MS specification)\nspw:\n    centrefreq: [229.0e9]                            # centre frequency of spw in Hz\n    bandwidth: [2e9]                               # bandwidth of spw in Hz\n    channels: [16]                                   # number of channels in spw\nstarttime: \"UTC,2021/04/28/00:00:00.00\"              # starting time of the first scan in the observation\n\n####################################################\n# settings for wsclean predict\n\nosfactor: 8191                                       # oversampling factor for WSClean\nskymodel: \"inputs/sourcemodels/point\"       # HDF5 file or directory containing FITS files\npolarized: false                                     # toggle source model polarization\nchannelgroups: 1                                     # number of groups to divide the channels into for computing source coherencies\n\n####################################################\n# common settings\n\ncorreff: 0.88                                      # correlator efficiency for 2 quantization bits (use 0.636 for 1-bit)\ncorruptseed: 456                                     # seed to be used for generating random variables for corruptions (except for troposphere)\ndiagnostics: true                                  # generate diagnostic plots and logs\n\n####################################################\n# settings for atmospheric corruptions\n\ntroposphere:                                         # add troposphere\n  enable: false\n  wetonly: false                                     # add only the wet component\n  attenuate: true                                   # signal attenuation due to opacity\n  skynoise: true                                    # add tropospheric contribution to sky noise\n  meandelays: true                                   # add mean delays\n  fixdelays: false                                   # add fixed delays \n  turbulence: true                                  # add turbulent phases\n  tropseed: 873256                                      # independent seed for generating random variables for troposphere\n\nionosphere:                                          # add ionosphere\n  enable: false\n\n####################################################\n# beam and pointing settings\n\npointing:\n  enable: true\n  mode: \"gp\"                                         # \"gp\" (Gaussian processes) or \"normal\" (Gaussian)\n  interval: 5.0                          # time interval (in seconds) after which to generate new pointing errors (<=0.0 for \"mean(coherencetime)\")\n  scale: 100.0                                   # scale mixture parameter for long-term smoothness\n\n####################################################\n# settings for instrumental polarization\n\ninstrumentalpolarization: \n  enable: false                                       # add instrumental polarization\n  mode: \"gp\"                                     # \"gp\" (Gaussian processes) or \"normal\" (Gaussian)\n  visibilityframe: \"sky\"                             # visibilities are written out in \"sky\" frame\n\n####################################################\n# settings for gains\n\nstationgains: \n  enable: false                                      # add antenna gains\n  mode: \"gp\"                                     # \"gp\" or \"normal\"\nbandpass: \n  enable: false                                      # add bandpass effects \n  bandpassfile: \"inputs/eht_2017.bandpass\" # csv file containing bandpass information for all stations\n\n####################################################\n# noise settings\n\nthermalnoise: \n  enable: false                                      # toggle thermal noise","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"Section 1 contains parameters for creating a new MS from scratch. If mode = \"uvfits\" then most of these are irrelevant (see here). The following sections contain parameters specific to the computation of various instrument models to be passed as arguments to corresponding functions.","category":"page"},{"location":"components/#Site-and-station-parameters","page":"Components","title":"Site and station parameters","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"CSV files containing station and weather parameters are used for a more detailed specification of the necessary input information. The station information file contains, for each station, the position of the antennas, weather parameters for computing atmospheric models, complex receiver gains and polarization leakage, and mount and feed information. An example station information file looks like this:","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"station,x_m,y_m,z_m,dishdiameter_m,sefd_Jy,pwv_mm,gpress_mb,gtemp_K,ctime_sec,pointingrms_arcsec,pbfwhm230_arcsec,pbmodel,aperture_eff,g_pol1_loc,g_pol1_scale,g_pol2_loc,g_pol2_scale,d_pol1_loc,d_pol1_scale,d_pol2_loc,d_pol2_scale,feedangle_deg,mount,feed\nAA,2225060.8136,-5440059.59994,-2481681.15054,73,60.0,1.5,555,271,10,1.0,27,gaussian,0.73,1.0+0.0im,0.1+0.1im,1.06+0.0im,0.1+0.1im,-0.05+0.03im,0.001+0.001im,0.03-0.04im,0.001+0.001im,0.0,ALT-AZ,linear\nAP,2225039.52970,-5441197.62920,-2479303.35970,12,3300.0,1.5,555,271,10,1.0,27,gaussian,0.63,0.95+0.06im,0.1+0.1im,1.0+0.07im,0.1+0.1im,0.03-0.03im,0.001+0.001im,0.05+0.03im,0.001+0.001im,0.0,ALT-AZ+NASMYTH-R,circular\nAZ,-1828796.20000,-5054406.80000,3427865.20000,10,7700.0,4.4,695,276,3,1.0,32,gaussian,0.57,1.1+0.0im,0.1+0.1im,0.9+0.0im,0.1+0.1im,0.03+0.04im,0.001+0.001im,0.035-0.03im,0.001+0.001im,0.0,ALT-AZ+NASMYTH-R,circular\nLM,-768715.63200,-5988507.07200,2063354.85200,32,2400.0,5.7,604,273,6,1.0,10,gaussian,0.31,1.1+0.05im,0.1+0.1im,1.2+0.1im,0.1+0.1im,0.03-0.03im,0.001+0.001im,0.03+0.0im,0.001+0.001im,0.0,ALT-AZ+NASMYTH-L,circular\nPV,5088967.74544,-301681.18586,3825012.20561,30,1000.0,2.9,723,273,4,0.5,11,gaussian,0.43,1.04+0.0im,0.1+0.1im,1.05+0.0im,0.1+0.1im,0.03+0.06im,0.001+0.001im,-0.04+0.03im,0.001+0.001im,0.0,ALT-AZ+NASMYTH-L,circular\nSM,-5464555.49300,-2492927.98900,2150797.17600,15,3300.0,1.5,626,278,5,1.5,55,gaussian,0.73,0.97+0.1im,0.1+0.1im,1.1+0.05im,0.1+0.1im,-0.03+0.03im,0.001+0.001im,0.045+0.0im,0.001+0.001im,45.0,ALT-AZ+NASMYTH-L,circular","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"The bandpass information file contains the amplitude and phase range of bandpass variations at different representative frequencies for each station, for each polarization. An example bandpass information file looks like this:","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"station,freq_Hz,pol1_amp,pol2_amp,pol1_phaserange_deg,pol2_phaserange_deg\nAA, 227.9, 0.5, 0.5, 30, 30\nAA, 228.5, 0.95, 0.95, 30, 30\nAA, 229.0, 1.0, 1.0, 30, 30\nAA, 229.5, 0.95, 0.95, 30, 30\nAA, 230.0, 0.5, 0.5, 30, 30\nAP, 227.9, 0.65, 0.65, 30, 30\nAP, 228.5, 0.95, 0.95, 30, 30\nAP, 229.0, 1.0, 1.0, 30, 30\nAP, 229.5, 0.95, 0.95, 30, 30\nAP, 230.0, 0.5, 0.5, 30, 30\nAZ, 227.9, 0.5, 0.5, 30, 30\nAZ, 228.5, 0.95, 0.95, 30, 30\nAZ, 229.0, 1.0, 1.0, 30, 30\nAZ, 229.5, 0.95, 0.95, 30, 30\nAZ, 230.0, 0.6, 0.6, 30, 30\nLM, 227.9, 0.5, 0.5, 30, 30\nLM, 228.5, 0.95, 0.95, 30, 30\nLM, 229.0, 1.0, 1.0, 30, 30\nLM, 229.5, 0.99, 0.99, 30, 30\nLM, 230.0, 0.5, 0.5, 30, 30\nPV, 227.9, 0.5, 0.5, 30, 30\nPV, 228.5, 0.95, 0.95, 30, 30\nPV, 229.0, 1.0, 1.0, 30, 30\nPV, 229.5, 0.95, 0.95, 30, 30\nPV, 230.0, 0.5, 0.5, 30, 30\nSM, 227.9, 0.7, 0.7, 30, 30\nSM, 228.5, 0.98, 0.98, 30, 30\nSM, 229.0, 1.0, 1.0, 30, 30\nSM, 229.5, 0.98, 0.98, 30, 30\nSM, 230.0, 0.7, 0.7, 30, 30","category":"page"},{"location":"components/#Other-input-files","page":"Components","title":"Other input files","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"Some other optional input file types required for creating an MS and computing source coherency are given below:","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"antenna_table.template/ is a template CASA ANTENNA table used to generate a complete ANTENNA table specific to the current observation. \nsourcemodels/ contains sky models (each model directory containing multiple FITS files named in a format that WSClean recognises) for computing source coherency matrix.\nuvfitsfiles/ contains sample uvfits files with visibility data for conversion to MS prior to applying instrument models.","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"Examples of all types of input files are available under inputs/. More can be found under test/data.","category":"page"},{"location":"components/#Output-files","page":"Components","title":"Output files","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"Various outputs such as a new MS, HDF5 file(s) containing generated instrument models and diagnostic plots are created at the end of a complete pipeline run. All these outputs are optional if a pre-existing MS is used. More details on these can be found in the Tutorial section.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"EditURL = \"../../../examples/computemodels.jl\"","category":"page"},{"location":"examples/computemodels/#Compute-instrument-models","page":"Compute instrument models","title":"Compute instrument models","text":"","category":"section"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"The primary goal of Anime is to generate instrument models tailored to observation specifications. The models are optionally stored in HDF5 format and plotted. Plotting functions using Plots.jl are provided.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"All functions that follow require loading the following modules:","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"relativepath = \"../../../\"\n\ninclude(joinpath(relativepath, \"src\", \"Anime.jl\"))\nusing .Anime\nusing HDF5\nusing Plots","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"We also load an observation from an existing MS to operate on.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"msname = joinpath(relativepath, \"test\", \"data\", \"ehtuvf.ms\")\nstations = joinpath(relativepath, \"inputs\", \"eht_2017.stations\")\ncorruptseed = 456\ntropseed = 54364\ntropwetonly =false\ncorreff = 0.88\ntropattenuate = true\ntropskynoise = true\ntropmeandelays = true\ntropturbulence = true\npolvisframe = \"sky\"\npolmode = \"gp\"\nptginterval = 5.0\nptgscale = 2.0\nptgmode = \"gp\"\ngainsmode = \"gp\"\nbpfile = joinpath(relativepath, \"test\", \"data\", \"eht_2017.bandpass\")\ndelim = \",\"\nignorerepeated = false\n\nobs = loadms(msname, stations, corruptseed, tropseed, tropwetonly, correff, tropattenuate, tropskynoise, tropmeandelays, tropturbulence, polvisframe,\npolmode, ptginterval, ptgscale, ptgmode, gainsmode, bpfile, delim=\",\", ignorerepeated=false)","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"A multi-frequency data set","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"obs1 = loadms(joinpath(relativepath, \"test\", \"data\", \"eht1.ms\"), stations, corruptseed, tropseed, tropwetonly, correff, tropattenuate, tropskynoise, tropmeandelays, tropturbulence, polvisframe,\npolmode, ptginterval, ptgscale, ptgmode, gainsmode, bpfile, delim=\",\", ignorerepeated=false)","category":"page"},{"location":"examples/computemodels/#Atmospheric-models","page":"Compute instrument models","title":"Atmospheric models","text":"","category":"section"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"At mm-wavelengths (230 GHz), the troposphere has significant effects on signal propagation. Anime re-implements in Julia all the tropospheric effects simulated by MEQSv2[1]. The advantage here is that apart from being faster and not requiring a regular grid of complex visibilities, they can be called from other imaging and calibration packages when necessary.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"The function troposphere! computes various tropospheric effects based on the flags set when loadms is called.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"note: Note\nThe external program AATM is requred to generate quantities related to tropospheric absorption and dispersion. Here we pass pre-existing CSV output from AATM to absorptionfile and dispersivefile. The elevation angles of all antennas during the course of the observation can also be preloaded when casatools are unavailable to generate them from scratch.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"h5file = \"sample.h5\"\nabsorptionfile = joinpath(relativepath, \"test\", \"data\", \"absorption1.csv\")\ndispersivefile = joinpath(relativepath, \"test\", \"data\", \"dispersive1.csv\")\nelevfile = joinpath(relativepath, \"test\", \"data\", \"insmodeluvf.h5\")\n\ntroposphere!(obs, h5file, absorptionfile=absorptionfile, dispersivefile=dispersivefile, elevfile=elevfile)","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"This computes the delays introduced by the mean and turbulent components of the troposphere, along with attenuation due to opacity and increase in system noise.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"Anime provides plotting functions that help visualize these models. In the following, the gaps in the plotted curves signify lags between two observing scans.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"For example, to plot the elevation angles by station we can just do","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"plotelevationangle(elevfile, obs.scanno, obs.times, obs.stationinfo.station, save=false)","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"The transmission values computed can be plotted using","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"plottransmission(h5file, obs.stationinfo.station, obs.times, obs.chanfreqvec, save=false)","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"Since this is a channel-averaged data set, the frequency-dependent transmission reduces to a single curve per station.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"The delays due to the mean component of the troposphere can be plotted as follows:","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"plotmeandelays(h5file, obs.stationinfo.station, obs.times, obs.chanfreqvec, save=false)","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"rm(h5file) # hide\nrm(\"atm.csv\") # hide","category":"page"},{"location":"examples/computemodels/#Primary-beam-response","page":"Compute instrument models","title":"Primary beam response","text":"","category":"section"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"We model the effects of antenna pointing offsets caused by various mechanical or electronic effects. The size of the primary beam affects how much the errors in antenna pointing attenuate the complex visibilities. Anime models the pointing offsets as Gaussian processes which are useful for modelling smooth variations in pointing over time.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"The function pointing! is used to compute and apply pointing models to data.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"pointing!(obs, h5file=h5file)","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"Note that this method is a shorthand for another method with multiple arguments that provides more fine-grained control over the input parameters.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"We now plot the pointing model generated:","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"plotpointingerrors(h5file, obs.scanno, obs.stationinfo.station, save=false)","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"Mispointings of station LM (Large Millimeter Telescope, Mexico), the largest dish in the array, result in the largest attenuation of amplitude.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"rm(h5file) # hide","category":"page"},{"location":"examples/computemodels/#Instrumental-polarization","page":"Compute instrument models","title":"Instrumental polarization","text":"","category":"section"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"The feed receptors are designed to be sensitive to orthogonal polarization states in either circular or linear bases. Due to imperfections in the feed (either mechanical or electronic), the orthogonal measurements \"leak\" into the other feed, thereby giving rise to a multiplicative Jones matrix with small non-zero off-diagonal terms. This feed error or leakage matrix is also known as the D-Jones term. In practice, this term can vary with frequency.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"Anime generates smoothly varying frequency-dependent D-terms using Gaussian processes, taking a location and a scale parameter that determine the amount of leakage at each station.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"inh5file = joinpath(relativepath, \"test\", \"data\", \"insmodeluvf.h5\")\ninstrumentalpolarization!(obs, h5file=h5file, elevfile=inh5file, parangfile=inh5file)","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"plotparallacticangle(h5file, obs.scanno, obs.times, obs.stationinfo.station, save=false)","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"plotdterms(h5file, obs.stationinfo.station, obs.chanfreqvec)","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"There is only one frequency channel since this is a channel-averaged data set.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"rm(h5file) # hide","category":"page"},{"location":"examples/computemodels/#Receiver-gains","page":"Compute instrument models","title":"Receiver gains","text":"","category":"section"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"Temporal variations in complex receiver gainsfor both feeds are modelled independently. The amplitudes are modelled using a Gaussian process kernel (such as SE) while the phases are modelled using a Wiener process with a given location and scale parameters.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"We use an observation with only 2 scans to illustrate this better.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"stationgains!(obs1, h5file=h5file)","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"plotstationgains(h5file, obs1.scanno, obs1.times, obs1.exposure, obs1.stationinfo.station)","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"rm(h5file) # hide","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"Also there is a complex bandpass gain variation that is modelled by using representative bandpass amplitude values at certain frequencies across the bandwidth and interpolated for the missing frequency channels.","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"bandpass!(obs1, h5file=h5file)","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"plotbandpass(h5file, obs1.stationinfo.station, obs1.chanfreqvec)","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"rm(h5file) # hide","category":"page"},{"location":"examples/computemodels/#References","page":"Compute instrument models","title":"References","text":"","category":"section"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"[1]: Natarajan I. et al. MeqSilhouette v2 (2022) MNRAS","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"","category":"page"},{"location":"examples/computemodels/","page":"Compute instrument models","title":"Compute instrument models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#Anime-API","page":"Anime API","title":"Anime API","text":"","category":"section"},{"location":"api/#Contents","page":"Anime API","title":"Contents","text":"","category":"section"},{"location":"api/","page":"Anime API","title":"Anime API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Index","page":"Anime API","title":"Index","text":"","category":"section"},{"location":"api/","page":"Anime API","title":"Anime API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Public-API","page":"Anime API","title":"Public API","text":"","category":"section"},{"location":"api/#Storage","page":"Anime API","title":"Storage","text":"","category":"section"},{"location":"api/","page":"Anime API","title":"Anime API","text":"Anime.msfromconfig\nAnime.msfromuvfits\nAnime.mstouvfits\nAnime.loadms\nAnime.postprocessms","category":"page"},{"location":"api/#Anime.msfromconfig","page":"Anime API","title":"Anime.msfromconfig","text":"msfromconfig(msname::String, mscreationmode::String, stations::String, casaanttemplate::String, spw_centrefreq::Array{Float64, 1}, \nspw_bw::Array{Float64, 1}, spw_channels::Array{Int64, 1}, sourcedict::Dict{String, Any}, starttime::String, exposure::Float64, scans::Int64,\nscanlengths::Array{Float64, 1}, scanlag::Float64; autocorr::Bool=false, telescopename::String=\"VLBA\", feed::String=\"perfect R L\",\nshadowlimit::Float64=1e-6, elevationlimit::String=\"10deg\", stokes::String=\"RR RL LR LL\", delim::String=\",\", ignorerepeated::Bool=false)\n\nCreate Measurement Set from observation parameters. Requires casatools.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.msfromuvfits","page":"Anime API","title":"Anime.msfromuvfits","text":"msfromuvfits(uvfits::String, msname::String, mscreationmode::String)\n\nConvert uvfits file to MS named msname. Requires casatools and casatasks to be installed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.mstouvfits","page":"Anime API","title":"Anime.mstouvfits","text":"mstouvfits(msname::String, uvfits::String, datacolumn::String; field::String=\"\", spw::String=\"\", antenna::String=\"\",\ntimerange::String=\"\", overwrite::Bool=false)\n\nConvert MS to UVFITS. Requires casatasks to be installed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.loadms","page":"Anime API","title":"Anime.loadms","text":"loadms(msname::String, stations::String, corruptseed::Int64, tropseed::Int64, tropwetonly::Bool, correff::Float64, tropattenuate::Bool,\ntropskynoise::Bool, tropmeandelays::Bool, tropturbulence::Bool, polframe::String, polmode::String, ptginterval::Float64, ptgscale::Float64, ptgmode::String,\nstationgainsmode::String, bandpassfile::String; delim::String=\",\", ignorerepeated::Bool=false)\n\nLoad data and metadata from MS and station & bandpass tables and return a CjlObservation object.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.postprocessms","page":"Anime API","title":"Anime.postprocessms","text":"postprocessms(obs::CjlObservation; h5file::String=\"\")\n\nAdd weight and sigma columns (write optionally to h5file), reshape as needed by MS, and write data stored in obs to disk.\n\n\n\n\n\n","category":"function"},{"location":"api/#Coherency","page":"Anime API","title":"Coherency","text":"","category":"section"},{"location":"api/","page":"Anime API","title":"Anime API","text":"Anime.run_wsclean","category":"page"},{"location":"api/#Anime.run_wsclean","page":"Anime API","title":"Anime.run_wsclean","text":"run_wsclean(msname::String, fitsdir::String, polarized::Bool, channelgroups::Int64, osfactor::Int64)\n\nCompute source coherency matrix using WSClean and populate MS. fitsdir is the directory containing FITS source models, polarized indicates if source model is polarized, and channelgroups is the number of images in frequency. osfactor is the oversampling factor which is a WSClean argument that controls prediction/imaging accuracy.\n\n\n\n\n\n","category":"function"},{"location":"api/#Instrument-Models","page":"Anime API","title":"Instrument Models","text":"","category":"section"},{"location":"api/","page":"Anime API","title":"Anime API","text":"Anime.troposphere!\nAnime.instrumentalpolarization!\nAnime.pointing!\nAnime.stationgains!\nAnime.bandpass!\nAnime.thermalnoise!","category":"page"},{"location":"api/#Anime.troposphere!","page":"Anime API","title":"Anime.troposphere!","text":"troposphere(obs::CjlObservation, h5file::String; absorptionfile=\"\", dispersivefile=\"\", elevfile=\"\")\n\nMain function to compute various components of the tropospheric model. The actual numerical values generated are serialized in HDF5 format.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.instrumentalpolarization!","page":"Anime API","title":"Anime.instrumentalpolarization!","text":"instrumentalpolarization!(data::Array{Complex{Float32},4}, scanno::Vector{Int32}, times::Vector{Float64}, stationinfo::DataFrame, phasedir::Array{Float64,2},\npos::Array{Float64, 2}, chanfreqvec::Vector{Float64}, polframe::String, polmode::String, antenna1::Vector{Int32}, antenna2::Vector{Int32}, \nexposure::Float64, rngcorrupt::AbstractRNG; h5file::String=\"\", elevfile::String=\"\", parangfile::String=\"\")\n\nCompute frequency-varying instrumental polarization (leakage, or \"D-Jones\" terms) and apply to data. The actual numerical values are serialized as HDF5.\n\n\n\n\n\ninstrumentalpolarization!(obs::CjlObservation; h5file::String=\"\", elevfile::String=\"\", parangfile::String=\"\")\n\nShorthand for instrumental polarization function when CjlObservation struct object is available.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.pointing!","page":"Anime API","title":"Anime.pointing!","text":"pointing!(data::Array{Complex{Float32},4}, stationinfo::DataFrame, scanno::Vector{Int32}, chanfreqvec::Vector{Float64}, \nptgint::Float64, ptgscale::Float64, ptgmode::String, exposure::Float64, times::Vector{Float64}, rngcorrupt::AbstractRNG, antenna1::Vector{Int32}, \nantenna2::Vector{Int32}, numchan::Int64; α=1.0, h5file::String=\"\")\n\nCompute pointing model and apply to data. The actual numerical values are serialized in HDF5 format.\n\n\n\n\n\npointing!(obs::CjlObservation; h5file::String=\"\")\n\nShorthand for pointing model function when CjlObservation struct object is available.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.stationgains!","page":"Anime API","title":"Anime.stationgains!","text":"stationgains!(data::Array{Complex{Float32},4}, scanno::Vector{Int32}, times::Vector{Float64}, exposure::Float64, \nstationinfo::DataFrame, mode::String, rngcorrupt::AbstractRNG, antenna1::Vector{Int32}, antenna2::Vector{Int32}, numchan::Int64; h5file::String=\"\")\n\nCompute time-variable complex station gains and apply to data. The actual numerical values are serialized in HDF5 format.\n\n\n\n\n\nstationgains!(obs::CjlObservation; h5file::String=\"\")\n\nShorthand for station gains function when CjlObservation struct object is available.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.bandpass!","page":"Anime API","title":"Anime.bandpass!","text":"bandpass!(data::Array{Complex{Float32},4}, bandpassfile::String, stationinfo::DataFrame, rngcorrupt::AbstractRNG,\nantenna1::Vector{Int32}, antenna2::Vector{Int32}, numchan::Int64, chanfreqvec::Vector{Float64}; h5file::String=\"\")\n\nCompute the complex bandpass model and apply to data. The actual numerical values are serialized in HDF5 format.\n\n\n\n\n\nbandpass!(obs::CjlObservation; h5file::String=\"\")\n\nShorthand for bandpass function when CjlObservation struct object is available.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.thermalnoise!","page":"Anime API","title":"Anime.thermalnoise!","text":"thermalnoise!(data::Array{Complex{Float32},4}, times::Vector{Float64}, antenna1::Vector{Int32}, antenna2::Vector{Int32}, correff::Float64,\nexposure::Float64, chanwidth::Float64, rngcorrupt::AbstractRNG, sefd::Vector{Float64}; h5file::String=\"\", noisefile::String=\"\")\n\nCompute per-baseline thermal noise using radiometer equation and apply to data. The actual numerical values are serialized in HDF5 format.\n\n\n\n\n\nthermalnoise!(obs::CjlObservation; h5file::String=\"\", noisefile::String=\"\")\n\nShorthand for thermal noise function when CjlObservation struct object is available.\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics","page":"Anime API","title":"Statistics","text":"","category":"section"},{"location":"api/","page":"Anime API","title":"Anime API","text":"Anime.genseries1d!","category":"page"},{"location":"api/#Anime.genseries1d!","page":"Anime API","title":"Anime.genseries1d!","text":"genseries1d!(series::Vector{ComplexF32}, mode::String, location::ComplexF32, scale::Float32, driftrate::Float32, nsamples::Int64, rng::AbstractRNG)\n\nGenerate a complex-valued Gaussian process 1-D series of length nsamples with the given location, scale, and driftrate parameters. mode determines if \"normal\" distribution or \"gaussian processes\" is used to generate the samples.\n\n\n\n\n\ngenseries1d!(series::Vector{Float32}, mode::String, location::Float32, scale::Float32, driftrate::Float32, nsamples::Int64, rng::AbstractRNG)\n\nGenerate a Float32-valued Gaussian process 1-D series of length nsamples with the given location, scale, and driftrate parameters. mode determines if \"normal\" distribution or \"gaussian processes\" is used to generate the samples.\n\n\n\n\n\ngenseries1d!(series::Vector{Float64}, mode::String, location::Float64, scale::Float64, driftrate::Float64, nsamples::Int64, rng::AbstractRNG)\n\nGenerate a Float64-valued Gaussian process 1-D series of length nsamples with the given location, scale, and driftrate parameters. mode determines if \"normal\" distribution or \"gaussian processes\" is used to generate the samples.\n\n\n\n\n\ngenseries1d!(series, times, rng::AbstractRNG; μ=0.0, σ=1.0, ρ=1.0)\n\nGenerate 1-D series using SE kernel.\n\n\n\n\n\ngenseries1d!(series, times, rng::AbstractRNG, α::Float64; μ=0.0, σ=1.0, ρ=2.0)\n\nGenerate 1-D series using RQ kernel.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utils","page":"Anime API","title":"Utils","text":"","category":"section"},{"location":"api/","page":"Anime API","title":"Anime API","text":"Anime.elevationangle\nAnime.parallacticangle","category":"page"},{"location":"api/#Anime.elevationangle","page":"Anime API","title":"Anime.elevationangle","text":"elevationangle(times::Vector{Float64}, phasedir::Array{Float64,2}, stationinfo::DataFrame, pos::Array{Float64, 2})\n\nCompute elevation angle for all stations in stationinfo for all times using phasedir and pos information.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.parallacticangle","page":"Anime API","title":"Anime.parallacticangle","text":"parallacticangle(times::Vector{Float64}, phasedir::Array{Float64,2}, stationinfo::DataFrame, pos::Array{Float64,2})\n\nCompute parallactic angle for all stations in stationinfo for all times using phasedir and pos information.\n\n\n\n\n\n","category":"function"},{"location":"api/#Plotting","page":"Anime API","title":"Plotting","text":"","category":"section"},{"location":"api/","page":"Anime API","title":"Anime API","text":"Anime.plotvis\nAnime.plotuvcov\nAnime.plotstationgains\nAnime.plotbandpass\nAnime.plotpointingerrors\nAnime.plotelevationangle\nAnime.plotparallacticangle\nAnime.plotdterms\nAnime.plottransmission\nAnime.plotmeandelays","category":"page"},{"location":"api/#Anime.plotvis","page":"Anime API","title":"Anime.plotvis","text":"plotvis(uvw::Matrix{Float64}, chanfreqvec::Array{Float64,1}, flag::Array{Bool,4}, data::Array{Complex{Float32},4},\nnumchan::Int64, times::Vector{Float64}; saveprefix=\"data_\")\n\nPlot complex visibilities against time and projected baseline length.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.plotuvcov","page":"Anime API","title":"Anime.plotuvcov","text":"plotuvcov(uvw::Matrix{Float64}, flagrow::Vector{Bool}, chanfreqvec::Vector{Float64}; saveprefix=\"test_\")\n\nPlot uv-coverage of observation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.plotstationgains","page":"Anime API","title":"Anime.plotstationgains","text":"plotstationgains(h5file::String, scanno::Vector{Int32}, times::Vector{Float64}, exposure::Float64, stationnames::Vector{String3}; save::Bool=true)::Plots.Plot{Plots.GRBackend}\n\nPlot complex station gains against time.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.plotbandpass","page":"Anime API","title":"Anime.plotbandpass","text":"plotbandpass(h5file::String, stationnames::Vector{String3}, chanfreqvec::Vector{Float64}; save::Bool=true)::Plots.Plot{Plots.GRBackend}\n\nPlot bandpass gains against time.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.plotpointingerrors","page":"Anime API","title":"Anime.plotpointingerrors","text":"plotpointingerrors(h5file::String, scanno::Vector{Int32}, stationnames::Vector{String3}; save::Bool=true)::Plots.Plot{Plots.GRBackend}\n\nPlot pointing errors.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.plotelevationangle","page":"Anime API","title":"Anime.plotelevationangle","text":"plotelevationangle(h5file::String, scanno::Vector{Int32}, times::Vector{Float64}, stationnames::Vector{String3}; save::Bool=true)::Plots.Plot{Plots.GRBackend}\n\nPlot evolution of station elevation angles during the course of the observation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.plotparallacticangle","page":"Anime API","title":"Anime.plotparallacticangle","text":"plotparallacticangle(h5file::String, scanno::Vector{Int32}, times::Vector{Float64}, stationnames::Vector{String3}; save::Bool=true)::Plots.Plot{Plots.GRBackend}\n\nPlot evolution of station parallactic angles during the course of the observation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.plotdterms","page":"Anime API","title":"Anime.plotdterms","text":"plotdterms(h5file::String, stationnames::Vector{String3}, chanfreqvec::Vector{Float64}; save::Bool=true)::Plots.Plot{Plots.GRBackend}\n\nPlot frequency-dependent complex instrumental polarization.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.plottransmission","page":"Anime API","title":"Anime.plottransmission","text":"plottransmission(h5file::String, stationnames::Vector{String3}, times::Vector{Float64}, chanfreqvec::Vector{Float64}; save::Bool=true)::Plots.Plot{Plots.GRBackend}\n\nPlot tropospheric transmission variation with frequency.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.plotmeandelays","page":"Anime API","title":"Anime.plotmeandelays","text":"plotmeandelays(h5file::String, stationnames::Vector{String3}, times::Vector{Float64}, chanfreqvec::Vector{Float64}; save::Bool=true)::Plots.Plot{Plots.GRBackend}\n\nPlot mean delays against time.\n\n\n\n\n\n","category":"function"},{"location":"api/#Data-Types","page":"Anime API","title":"Data Types","text":"","category":"section"},{"location":"api/","page":"Anime API","title":"Anime API","text":"Anime.CjlObservation","category":"page"},{"location":"api/#Anime.CjlObservation","page":"Anime API","title":"Anime.CjlObservation","text":"struct CjlObservation{T} <: Anime.AbstractObservation{T}\n\nContainer type for storing observation parameters and data.\n\nFields\n\nmsname: Name of the Measurement Set\n\ndata: Complex visibility data (MS DATA column)\n\nflag: Flag array of the same dimensions as data (MS FLAG column)\n\nflagrow: Flag row Boolean vector (MS FLAG_ROW column)\n\nantenna1: Antenna 1 in a baseline pair (MS ANTENNA1 column)\n\nantenna2: Antenna 2 in a baseline pair (MS ANTENNA2 column)\n\nuvw: uvw coordinates (MS UVW column)\n\ntimes: Timestamps (MS TIME column)\n\nexposure: Integration time\n\nscanno: Scan numbers (MS SCAN_NUMBER column)\n\nnumchan: Number of frequency channels\n\nchanfreqvec: Channel frequencies (Hz) (MS CHAN_FREQ column)\n\nchanwidth: Width of frequency channel\n\nphasedir: Direction of phase centre\n\npos: Antenna positions in x,y,z coordinates\n\nstationinfo: Dataframe of station information input by user\n\ntropwetonly: Consider only water vapour in the troposphere\n\ncorreff: Correlator efficiency\n\ntropattenuate: Introduce attenuation by the troposphere\n\ntropskynoise: Introduce noise due to troposphere\n\ntropmeandelays: Introduce mean delays due to troposphere\n\ntropturbulence: Introduce turbulence in troposphere\n\npolframe: Polarization frame\n\npolmode: Mode to use to create frequency-varying D-term samples\n\nptginterval: Pointing interval (s)\n\nptgscale: Pointing scale mixture parameter\n\nptgmode: Mode to use to create pointing error time samples\n\nstationgainsmode: Mode to use to create station gain time samples\n\nbandpassfile: Input bandpass file\n\nrngcorrupt: RNG for all models except troposphere\n\nrngtrop: RNG for tropospheric models\n\n\n\n\n\n","category":"type"},{"location":"api/#Internal","page":"Anime API","title":"Internal","text":"","category":"section"},{"location":"api/","page":"Anime API","title":"Anime API","text":"Anime.addweightcols\nAnime.makecasaanttable\nAnime.copymodeltodata\nAnime.computeweights!\nAnime.run_aatm\nAnime.compute_transmission!\nAnime.attenuate!\nAnime.compute_skynoise!\nAnime.compute_meandelays!\nAnime.compute_turbulence!\nAnime.squaredexponentialkernel\nAnime.rationalquadratickernel","category":"page"},{"location":"api/#Anime.addweightcols","page":"Anime API","title":"Anime.addweightcols","text":"addweightcols(msname::String, mode::String, sigmaspec::Bool, weightspec::Bool)\n\nAdd WEIGHT_SPECTRUM and SIGMA_SPECTRUM columns to MS. Requires casatools to be installed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.makecasaanttable","page":"Anime API","title":"Anime.makecasaanttable","text":"makecasaanttable(stations::String, casaanttemplate::String; delim::String=\",\", ignorerepeated::Bool=false)\n\nCreate CASA antenna table from station info file stations using casaanttemplate as template. Requires casatools to be installed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.copymodeltodata","page":"Anime API","title":"Anime.copymodeltodata","text":"copymodeltodata(msname::String)\n\nCopy MODEL_DATA to DATA in MS msname.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.computeweights!","page":"Anime API","title":"Anime.computeweights!","text":"computeweights!(totalrmsspec::Array{Float32, 4}, totalwtspec::Array{Float32, 4}; h5file::String=\"\")\n\nCompute total rms (sigma) values and inverse-squared visibility weights from thermal+sky noise terms stored in h5file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.run_aatm","page":"Anime API","title":"Anime.run_aatm","text":"run_aatm(obs::CjlObservation; absorptionfile::String=\"\", dispersivefile::String=\"\")::DataFrame\n\nRun AATM (Bjona Nikolic; Pardo et al. 2001) to compute absorption by and dispersive delay in the troposphere. If AATM is not installed, this function can still accept input absorption and dispersion values in a specific CSV format and populate atm.csv.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.compute_transmission!","page":"Anime API","title":"Anime.compute_transmission!","text":"compute_transmission!(transmission::Array{Float64, 3}, obs::CjlObservation, atmdf::DataFrame, elevationmatrix::Array{Float64, 2}, g::HDF5.Group)::Array{Float64, 3}\n\nCompute elevation-dependent (mean) tropospheric transmission given opacity τ and elevation angle θ for each station.\n\ne^-τsintheta_rm el\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.attenuate!","page":"Anime API","title":"Anime.attenuate!","text":"attenuate!(obs::CjlObservation, transmission::Array{Float64, 3})\n\nAttenuate the signal as it passes through (mean) troposphere using precomputed transmission values.\n\nI = I_0 e^-τsintheta_rm el\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.compute_skynoise!","page":"Anime API","title":"Anime.compute_skynoise!","text":"compute_skynoise!(obs::CjlObservation, atmdf::DataFrame, transmission::Array{Float64, 3}, g::HDF5.Group)\n\nCompute sky contribution to visibility noise using the radiometer equation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.compute_meandelays!","page":"Anime API","title":"Anime.compute_meandelays!","text":"compute_meandelays!(obs::CjlObservation, atmdf::DataFrame, elevationmatrix::Array{Float64, 2}, g::HDF5.Group)\n\nCompute delays due to (mean) troposphere.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.compute_turbulence!","page":"Anime API","title":"Anime.compute_turbulence!","text":"compute_turbulence!(obs::CjlObservation, atmdf::DataFrame, elevationmatrix::Array{Float64, 2}, g::HDF5.Group)\n\nCompute phase delays due to tropospheric turbulence. The time series of phase errors for station p is given by\n\ndelta phi_p(t nu) = frac1sqrtsin(theta_mathrmel(t)) deltaphi^prime_p(t) big(fracnunu_0big)\n\nwhere ν is the list of channel frequencies and ν_0 is the reference frequency (lowest in the band).\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.squaredexponentialkernel","page":"Anime API","title":"Anime.squaredexponentialkernel","text":"squaredexponentialkernel(x1, x2; σ=1.0, ρ=1.0)\n\nGenerate squared exponential kernel function of the form\n\nk_SE(x-x) = sigma^2 e^-frac(x-x)^22rho^2\n\nwhere σ^2 is the variance and ρ is the characteristic length.\n\n\n\n\n\n","category":"function"},{"location":"api/#Anime.rationalquadratickernel","page":"Anime API","title":"Anime.rationalquadratickernel","text":"rationalquadratickernel(x1, x2; σ=1.0, α=1.0, ρ=2.0)\n\nGenerate rational quadratic kernel of the form\n\nk_RQ(x-x) = sigma^2 big(1+frac(x-x)^22alpharho^2big)^-alpha\n\n\n\n\n\n","category":"function"},{"location":"examples/loadobservation/","page":"Read/write MS","title":"Read/write MS","text":"EditURL = \"../../../examples/loadobservation.jl\"","category":"page"},{"location":"examples/loadobservation/#Read/write-MS","page":"Read/write MS","title":"Read/write MS","text":"","category":"section"},{"location":"examples/loadobservation/","page":"Read/write MS","title":"Read/write MS","text":"Anime stores all information necessary to compute and apply instrument models to data in a custom structure of Arrays (see CjlObservation). All relevant data are read from the MS into this struct using loadms.","category":"page"},{"location":"examples/loadobservation/","page":"Read/write MS","title":"Read/write MS","text":"Load necessary modules","category":"page"},{"location":"examples/loadobservation/","page":"Read/write MS","title":"Read/write MS","text":"relativepath = \"../../../\"\n\ninclude(joinpath(relativepath, \"src\", \"Anime.jl\"))\nusing .Anime","category":"page"},{"location":"examples/loadobservation/","page":"Read/write MS","title":"Read/write MS","text":"For this example, we will load an MS from the test/data/ directory.","category":"page"},{"location":"examples/loadobservation/","page":"Read/write MS","title":"Read/write MS","text":"msname = joinpath(relativepath, \"test\", \"data\", \"eht1.ms\")\nstations = joinpath(relativepath, \"inputs\", \"eht_2017.stations\")\ncorruptseed = 456\ntropseed = 54364\ntropwetonly = false\ncorreff = 0.88\ntropattenuate = true\ntropskynoise = true\ntropmeandelays = true\ntropturbulence = true\npolvisframe = \"sky\"\npolmode = \"gp\"\nptginterval = 5.0\nptgscale = 2.0\nptgmode = \"gp\"\ngainsmode = \"gp\"\nbpfile = joinpath(relativepath, \"test\", \"data\", \"eht_2017.bandpass\")\ndelim = \",\"\nignorerepeated = false\n\nobs = loadms(msname, stations, corruptseed, tropseed, tropwetonly, correff, tropattenuate, tropskynoise, tropmeandelays, tropturbulence, polvisframe,\npolmode, ptginterval, ptgscale, ptgmode, gainsmode, bpfile, delim=\",\", ignorerepeated=false)","category":"page"},{"location":"examples/loadobservation/","page":"Read/write MS","title":"Read/write MS","text":"All subsequent computations are performed on this structure until the user calls postprocessms to write the results back to the MS. This function optionally requires an HDF5 file containing the noise generated for populating the WEIGHT and SIGMA arrays in the MS. If no HDF5 file is provided, these arrays are initialized to 1.0 and 0.0 respectively.","category":"page"},{"location":"examples/loadobservation/","page":"Read/write MS","title":"Read/write MS","text":"We first load a pre-existing HDF5 file containing instrument models generated according to the dimensions required by eht1.ms that we loaded in the previous step.","category":"page"},{"location":"examples/loadobservation/","page":"Read/write MS","title":"Read/write MS","text":"h5file = joinpath(relativepath, \"test\", \"data\", \"insmodel1.h5\")\n\npostprocessms(obs, h5file=h5file)","category":"page"},{"location":"examples/loadobservation/","page":"Read/write MS","title":"Read/write MS","text":"The above function call writes the contents of obs back into the MS.","category":"page"},{"location":"examples/loadobservation/","page":"Read/write MS","title":"Read/write MS","text":"note: Note\nCurrently Casacore.jl does not provide a way to cleanly close and release the read-write lock to an MS. If further processing is required using a different library such as casatools it is recommended to do that in a new REPL session.","category":"page"},{"location":"examples/loadobservation/","page":"Read/write MS","title":"Read/write MS","text":"","category":"page"},{"location":"examples/loadobservation/","page":"Read/write MS","title":"Read/write MS","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"EditURL = \"../../../examples/pipeline.jl\"","category":"page"},{"location":"examples/pipeline/#Running-in-pipeline-mode","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"","category":"section"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"Anime can be run in pipeline mode with little to no user interaction once the pipeline has started execution. This mode can include everything from creating a new data set from scratch to computing coherency matrices, computing and applying instrumental models to complex visibilities, and writing gain tables and making diagnostic plots. Note that some steps may involve the use of external software such as WSClean.","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"Import the necessary modules","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"using ArgParse\nusing Logging\nusing HDF5\nusing YAML\nusing Anime","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"Set some convenient command-line options for the script.","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"# create argument parser\nfunction create_parser()\n    s = ArgParseSettings()\n\n    @add_arg_table s begin\n        \"config\"#\n            help = \"Input YAML file name with observation configuration\"\n            required = true\n        \"outdir\"\n            help = \"Directory to hold output products\"\n            required = true\n        \"--clobber\", \"-c\"\n            action = :store_true\n            help = \"Delete and create output directory anew\"\n    end\n\n    return parse_args(s)\nend\n\n# create parser\nargs = create_parser()","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"Create a new working directory within which all output products will be stored.","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"# change working directory to the user-specified output directory\nstartdir = pwd() # store original working directory\nconfig = abspath(startdir, args[\"config\"])\noutdir = abspath(startdir, args[\"outdir\"])\n\n# create a new empty output directory\nif isdir(outdir)\n    if args[\"clobber\"]\n        run(`rm -rf $(outdir)`)\n\tmkdir(outdir)\n    else\n\terror(\"$outdir exists but -c option is not given 🤷\")\n    end\nelse\n    mkdir(outdir)\nend\n@info(\"Changing working directory to $outdir\")\ncd(outdir)","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"Now we load the YAML file containing the observation and instrument modelling parameters. While this is not mandatory, it is far easier to keep track of the input settings when a configuration file is used.","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"y = YAML.load_file(config, dicttype=Dict{String,Any}) # load YAML config file\nh5file = \"insmodel.h5\"","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"Generate a new data set from either the YAML file observation parameters or a previously existing UVFITS file. An ASCII file containing station information (Site-and-station-parameters) is necessary in both cases. Also see Creating-data-sets.","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"if y[\"mode\"] == \"manual\"\n    msfromconfig(y[\"msname\"], y[\"mode\"], y[\"stations\"], y[\"casaanttemplate\"], y[\"spw\"][\"centrefreq\"], y[\"spw\"][\"bandwidth\"], y[\"spw\"][\"channels\"],\n    y[\"source\"], y[\"starttime\"], y[\"exposure\"], y[\"scans\"], y[\"scanlengths\"], y[\"scanlag\"]; autocorr=y[\"autocorr\"], telescopename=y[\"telescopename\"],\n    feed=y[\"feed\"], shadowlimit=y[\"shadowlimit\"], elevationlimit=y[\"elevationlimit\"], stokes=y[\"stokes\"], delim=\",\", ignorerepeated=false)\nelseif y[\"mode\"] == \"uvfits\"\n    msfromuvfits(y[\"uvfits\"], y[\"msname\"], y[\"mode\"])\nelse\n    error(\"MS generation mode '$(y[\"mode\"])' not recognised 🤷\")\nend","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"Once a new MS has been generated, we can populate the source coherency in the DATA column using any visibility prediction software. Here, we use WSClean to compute source coherency (also see Compute-coherency-matrix):","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"run_wsclean(y[\"msname\"], y[\"skymodel\"], y[\"polarized\"], y[\"channelgroups\"], y[\"osfactor\"])","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"Now we load the data into a custom struct:","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"obs = loadms(y[\"msname\"], y[\"stations\"], Int(y[\"corruptseed\"]), Int(y[\"troposphere\"][\"tropseed\"]), y[\"troposphere\"][\"wetonly\"], y[\"correff\"],\ny[\"troposphere\"][\"attenuate\"], y[\"troposphere\"][\"skynoise\"], y[\"troposphere\"][\"meandelays\"], y[\"troposphere\"][\"turbulence\"],\ny[\"instrumentalpolarization\"][\"visibilityframe\"], y[\"instrumentalpolarization\"][\"mode\"], y[\"pointing\"][\"interval\"], y[\"pointing\"][\"scale\"],\ny[\"pointing\"][\"mode\"], y[\"stationgains\"][\"mode\"], y[\"bandpass\"][\"bandpassfile\"], delim=\",\", ignorerepeated=false)","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"We can now start adding the individual instrument models. For more details, see Compute-instrument-models.","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"y[\"troposphere\"][\"enable\"] && troposphere!(obs, h5file)\ny[\"instrumentalpolarization\"][\"enable\"] && instrumentalpolarization!(obs, h5file=h5file)\ny[\"pointing\"][\"enable\"] && pointing!(obs, h5file=h5file)\ny[\"stationgains\"][\"enable\"] && stationgains!(obs, h5file=h5file)\ny[\"bandpass\"][\"enable\"] && bandpass!(obs, h5file=h5file)\ny[\"thermalnoise\"][\"enable\"] && thermalnoise!(obs, h5file=h5file)","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"Compute weights, write everything back to disk, and convert to uvfits","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"postprocessms(obs, h5file=h5file)\nmstouvfits(y[\"msname\"], \"test.uvfits\", \"corrected\")","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"Change back to original working directory and exit","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"cd(startdir)\n@info(\"Anime.jl observation completed successfully 📡\")","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"","category":"page"},{"location":"examples/pipeline/","page":"Running in pipeline mode","title":"Running in pipeline mode","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/computecoherency/","page":"Compute coherency matrix","title":"Compute coherency matrix","text":"EditURL = \"../../../examples/computecoherency.jl\"","category":"page"},{"location":"examples/computecoherency/#Compute-coherency-matrix","page":"Compute coherency matrix","title":"Compute coherency matrix","text":"","category":"section"},{"location":"examples/computecoherency/","page":"Compute coherency matrix","title":"Compute coherency matrix","text":"The Radio Interferometer Measurement Equation (RIME)[HBS][OMS] lies at the heart of modelling interferometric observations. A generic discrete RIME can be written as","category":"page"},{"location":"examples/computecoherency/","page":"Compute coherency matrix","title":"Compute coherency matrix","text":"mathbfV_pq = G_p left( sum_s E_sp mathbfX_spq E_sq^H right) G_q^H","category":"page"},{"location":"examples/computecoherency/","page":"Compute coherency matrix","title":"Compute coherency matrix","text":"where the summation is carried out over all the sources s, and boldsymbolE_sp and boldsymbolG_p denote generic direction-dependent effects (DDEs) and direction-independent effects (DIEs) respectively. Each term is a 2times2 Jones matrix that describes any linear transformation acting on the incoming wave, and H is the Hermitian conjugate. X_spq is the source coherency matrix given by","category":"page"},{"location":"examples/computecoherency/","page":"Compute coherency matrix","title":"Compute coherency matrix","text":"X_spq = mathrmB e^-2pi i (u_pql + v_pqm + w_pq(n-1)) mathbfu_pq = mathbfu_p - mathbfu_q","category":"page"},{"location":"examples/computecoherency/","page":"Compute coherency matrix","title":"Compute coherency matrix","text":"where mathrmB is the brightness matrix, l, m, n are direction cosines, and mathbfu_pq are the baseline uvw coordinates.","category":"page"},{"location":"examples/computecoherency/","page":"Compute coherency matrix","title":"Compute coherency matrix","text":"While computing instrument models is the main aim of Anime we also provide a way to compute source coherency matrices by calling the external program WSClean:","category":"page"},{"location":"examples/computecoherency/","page":"Compute coherency matrix","title":"Compute coherency matrix","text":"msname = \"../../../test/data/eht.ms\"\nskymodel = \"../../../test/data/grmhdpol\"\npolarized = true\nchannelgroups = 1\noversamplingfactor = 8191\n\nrun_wsclean(msname, skymodel, polarized, channelgroups, oversamplingfactor)","category":"page"},{"location":"examples/computecoherency/","page":"Compute coherency matrix","title":"Compute coherency matrix","text":"note: Note\nThis function cannot be used if WSClean is not installed. This will soon be replaced by native computation of source coherency matrices.","category":"page"},{"location":"examples/computecoherency/#References","page":"Compute coherency matrix","title":"References","text":"","category":"section"},{"location":"examples/computecoherency/","page":"Compute coherency matrix","title":"Compute coherency matrix","text":"[HBS]: Hamaker J.P, Bregman J.D., Sault R.J. Understanding radio polarimetry (1996) AAPS","category":"page"},{"location":"examples/computecoherency/","page":"Compute coherency matrix","title":"Compute coherency matrix","text":"[OMS]: Smirnov O.M (2011) Revisiting the radio interferometry measurement equation A&A","category":"page"},{"location":"examples/computecoherency/","page":"Compute coherency matrix","title":"Compute coherency matrix","text":"","category":"page"},{"location":"examples/computecoherency/","page":"Compute coherency matrix","title":"Compute coherency matrix","text":"This page was generated using Literate.jl.","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Anime can be installed using Julia's package manager by entering the Julia REPL and typing","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"Anime\")","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"or by entering package mode by typing ] in the Julia REPL and then typing","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"add Anime","category":"page"},{"location":"install/#External-Software","page":"Installation","title":"External Software","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Some features of Anime require external software to be installed. These are optional and it is entirely possible to use Anime without them at the cost of some functionality.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"The python packages casatools, casatasks, and casadata are required to handle the creation of Measurement Sets (MS) and conversion between uvfits and MS formats. These are automatically installed when Anime is installed via Pkg.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"WSClean[1] is required to compute coherency matrices from FITS images into Measurement Sets. This is not possible to do in Anime without WSClean currently. Complex visibilities in uvfits/MS formats with precomputed coherency matrices can still be used. On Debian-based systems WSClean can be installed via apt-get:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"sudo apt-get install wsclean","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"AATM[2] is required for computing atmospheric quantities required for generating the atmospheric model, such as transmission, dry and wet path lengths, and sky temperature. In the absence of AATM, precomputed values for these quantities can still be passed in CSV format to compute tropospheric model. Before installing AATM ensure that the boost libraries are installed. On Debian-based system this can be done via apt-get:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"sudo apt-get install libboost-program-options-dev","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Once boost is installed, AATM can be compiled as follows:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"cd /path/to/aatm-source-code\n./configure --prefix=/path/to/aatm-installation\nmake\nmake install\nexport PATH=$PATH:/path/to/install/aatm-installation/bin","category":"page"},{"location":"install/#References","page":"Installation","title":"References","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"[1]: Offringa A. R. et al. WSCLEAN: an implementation of a fast, generic wide-field imager for radio astronomy (2014) MNRAS","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"[2]: Atmospheric transmission at microwaves (ATM): an improved model for millimeter/submillimeter applications IEEE Xplore","category":"page"},{"location":"examples/createdataset/","page":"Creating data sets","title":"Creating data sets","text":"EditURL = \"../../../examples/createdataset.jl\"","category":"page"},{"location":"examples/createdataset/#Creating-data-sets","page":"Creating data sets","title":"Creating data sets","text":"","category":"section"},{"location":"examples/createdataset/","page":"Creating data sets","title":"Creating data sets","text":"Anime uses the CASA Measurement Set (MS) data format as on-disk storage format from which data are read and written back to. Conversion to and from the more traditional uvfits format is also supported. While there is no standard format for storing VLBI data, support for a handful of commonly used data formats will be made available.","category":"page"},{"location":"examples/createdataset/","page":"Creating data sets","title":"Creating data sets","text":"We load the necessary modules first.","category":"page"},{"location":"examples/createdataset/","page":"Creating data sets","title":"Creating data sets","text":"relativepath = \"../../../\"\n\ninclude(joinpath(relativepath, \"src\", \"Anime.jl\"))\nusing .Anime\n#using Anime","category":"page"},{"location":"examples/createdataset/#In-manual-mode","page":"Creating data sets","title":"In manual mode","text":"","category":"section"},{"location":"examples/createdataset/","page":"Creating data sets","title":"Creating data sets","text":"In manual mode, the function msfromconfig is used to create an MS from scratch, with the observation and site parameters passed as arguments. The casatools python library is used under the hood.","category":"page"},{"location":"examples/createdataset/","page":"Creating data sets","title":"Creating data sets","text":"msname = \"eht.ms\"\nmode = \"manual\"\nstations = joinpath(relativepath, \"inputs\", \"eht_2017.stations\")\ncasaanttemplate = joinpath(relativepath, \"inputs\", \"antenna_table.template\")\nspw_centrefreq = [229.0e9]\nspw_bw = [2.0e9]\nspw_channels = [32]\nsourcedict = Dict{String, Any}(\"M87\" => Dict{String, String}(\"RA\"=>\"12h30m49.42\", \"Dec\"=>\"+12.23.28.04\", \"epoch\"=>\"J2000\"))\nstarttime = \"UTC,2021/04/28/00:00:00.00\"\nexposure = 1.0\nscans = 2\nscanlengths = [900.0, 600.0]\nscanlag = 300.0\nautocorr = false\ntelescopename = \"VLBA\"\nfeed = \"perfect R L\"\nshadowlimit = 1e-6\nelevationlimit = \"10deg\"\nstokes = \"RR RL LR LL\"\ndelim = \",\"\nignorerepeated = false\n\nmsfromconfig(msname, mode, stations, casaanttemplate, spw_centrefreq, spw_bw, spw_channels, sourcedict, starttime, exposure, scans, scanlengths, scanlag;\n autocorr=autocorr, telescopename=telescopename, feed=feed, shadowlimit=shadowlimit, elevationlimit=elevationlimit, stokes=stokes,\n delim=delim, ignorerepeated=ignorerepeated)","category":"page"},{"location":"examples/createdataset/","page":"Creating data sets","title":"Creating data sets","text":"The above step creates a fully functional MS that can be used for further processing.","category":"page"},{"location":"examples/createdataset/","page":"Creating data sets","title":"Creating data sets","text":"rm(\"eht.ms\", force=true, recursive=true) # hide\n\nrm(\"ANTENNA_eht_2017\", force=true, recursive=true) # hide","category":"page"},{"location":"examples/createdataset/#In-uvfits-mode","page":"Creating data sets","title":"In uvfits mode","text":"","category":"section"},{"location":"examples/createdataset/","page":"Creating data sets","title":"Creating data sets","text":"This method accepts an existing uvfits file (e.g. output by eht-imaging) and uses CASA to convert between the two formats. This is done via msfromuvfits:","category":"page"},{"location":"examples/createdataset/","page":"Creating data sets","title":"Creating data sets","text":"uvfits = joinpath(relativepath, \"inputs\", \"uvfitsfiles\", \"hops_lo_3601_M87+zbl-dtcal_selfcal.uvfits\")\nmsname = \"eht.ms\"\nmode = \"uvfits\"\n\nmsfromuvfits(uvfits, msname, mode)","category":"page"},{"location":"examples/createdataset/","page":"Creating data sets","title":"Creating data sets","text":"It is the responsibility of the user to ensure that the input uvfits file contains all the necessary information that CASA would need to create an MS. eht-imaging output files are consistent with these specifications.","category":"page"},{"location":"examples/createdataset/","page":"Creating data sets","title":"Creating data sets","text":"A helper function to convert an MS back to uvfits format is also provided:","category":"page"},{"location":"examples/createdataset/","page":"Creating data sets","title":"Creating data sets","text":"msname = \"eht.ms\"\nuvfits = \"eht.uvfits\"\ndatacolumn = \"data\"\n\nmstouvfits(msname, uvfits, datacolumn)\n\nrm(\"eht.ms\", force=true, recursive=true) # hide\n\nrm(\"eht.uvfits\", force=true, recursive=true) # hide\n\nrm(\"ANTENNA_eht_2017\", force=true, recursive=true) # hide","category":"page"},{"location":"examples/createdataset/","page":"Creating data sets","title":"Creating data sets","text":"","category":"page"},{"location":"examples/createdataset/","page":"Creating data sets","title":"Creating data sets","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Anime","category":"page"},{"location":"#Anime","page":"Home","title":"Anime","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Atmospheric aNd Instrumental models in the Measurement Equation - Anime - is an instrument modelling framework for radio interferometry written in Julia, an open source, high performance language for scientific computing. Anime aims to support efficient handling of various data formats commonly used in VLBI, provide seamless conversion between these formats and a variety of data products as output by a Very Long Baseline Interferometry (VLBI) array, and integrate with other Julia-based software packages for VLBI data analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Signals from astronomical sources are affected by various effects (e.g. atmospheric, mechanical, electronic) along the propagation path before they are recorded. Some of these effects can be modelled from first principles while for others a phenomenological approach that captures the statistical properties of the effect is more useful. Modelling these effects is an important step towards understanding both the astronomical source of interest and the capabilities and limitations of existing and planned instruments.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Within the EHT, two software packages are generally used for simulating interferometric observations of black holes: ngehtsim[DP] and SYMBA[RJ2020]. While ngehtsim follows an a posteriori approach to generate synthetic VLBI data whose statistical properties closely match real VLBI data by adding new functionality to the core eht-imaging[AC2018] functions, SYMBA uses MeqSilhouette v2 (MEQSv2)[IN2022][TB2017] to generate uncalibrated synthetic data using a physics-based a priori approach to simulate certain propagation path effects and rPICARD[MJ2019] to calibrate these data to simulate realistic calibration errors. These packages complement each other: ngehtsim can introduce some data corruptions and generate data sets faster and SYMBA/MEQSv2 can introduce more complex propagation path effects but at a higher computational cost due to its being a full-fledged pipeline with many moving parts implemented in bash and python that stitch together data products from different \"monolothic\" stages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Anime is designed to provide a complete framework in Julia to compute instrument models from first principles wherever possible and to generate synthetic VLBI data sets with support for and convert b/w multiple VLBI data storage formats. It can construct instrument models for multi-scan VLBI observations with irregulary-spaced and missing data without having to construct a regular grid of complex visibilities in baseline and time (like SYMBA/MEQSv2), thereby speeding up the generation of synthetic data. It also constructs more realistic models, re-implementing existing models from SYMBA/MEQSv2 in Julia for more efficient computation and introducing new ones. The ultimate aim is to be able to read/write commonly used on-disk data formats in VLBI and provide a set of instrument modelling functions that other software written in Julia (e.g. Comrade[PT2022]) can import and use for synthetic data generation, calibration and imaging. Inference methods for emulating the statistical properties of actual data are also in development.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"install.md\",\n    \"components.md\",\n    \"instrumentmodels.md\",\n    \"examples.md\",\n    \"api.md\"\n]","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[DP]: Pesce et al. (in prep) GitHub (Docs)","category":"page"},{"location":"","page":"Home","title":"Home","text":"[RJ2020]: Roelofs F., Janssen M., Natarajan I. et al. SYMBA: An end-to-end VLBI synthetic data generation pipeline (2020) A&A","category":"page"},{"location":"","page":"Home","title":"Home","text":"[AC2018]: Chael A. et al., Interferometric Imaging Directly with Closure Phases and Closure Amplitudes (2018) ApJ","category":"page"},{"location":"","page":"Home","title":"Home","text":"[IN2022]: Natarajan I. et al. MeqSilhouette v2: spectrally resolved polarimetric synthetic data generation for EHT (2022) MNRAS","category":"page"},{"location":"","page":"Home","title":"Home","text":"[TB2017]: Blecher T. et al. MEQSILHOUETTE: a mm-VLBI observation and signal corruption simulator (2017) MNRAS","category":"page"},{"location":"","page":"Home","title":"Home","text":"[MJ2019]: Janssen M. et al. rPICARD: A CASA-based calibration pipeline for VLBI data (2019) A&A","category":"page"},{"location":"","page":"Home","title":"Home","text":"[PT2022]: Tiede P. Comrade: Composable Modeling of Radio Emission (2022) JOSS","category":"page"},{"location":"instrumentmodels/#Instrument-Models","page":"Instrument Models","title":"Instrument Models","text":"","category":"section"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"VLBI enables the highest angular resolution achievable in astronomy, up to ~20 μas in the case of the Event Horizon Telescope (EHT) that produced the first ever images of a black hole in 2019. Since VLBI uses a sparse, heterogeneous array of radio telescopes situated around the planet, reconstructing images of observed astronomical sources is an ill-posed problem, and a deeper understanding of not only the astronomical source of interest but the instrument itself becomes crucial. Detailed explanation of the theory behind the aspects of the instrument that are modelled can be found in standard textbooks[TMS] and other references scattered throughout this documentation.","category":"page"},{"location":"instrumentmodels/#Radio-Interferometer-Measurement-Equation","page":"Instrument Models","title":"Radio Interferometer Measurement Equation","text":"","category":"section"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"The Radio Interferometer Measurement Equation (RIME)[HBS][OMS] lies at the heart of modelling interferometric observations. A generic discrete RIME can be written as","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"mathbfV_pq = G_p left( sum_s E_sp mathbfX_spq E_sq^H right) G_q^H","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"where the summation is carried out over all the sources s, and boldsymbolE_sp and boldsymbolG_p denote generic direction-dependent effects (DDEs) and direction-independent effects (DIEs) respectively. Each term is a 2times2 Jones matrix that describes any linear transformation acting on the incoming wave, and H is the Hermitian conjugate.","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"Forward modelling the instrument consists of generating the Jones matrices in a physically meaningful way. Anime can currently model effects such as tropospheric absorption and emission and phase delays, instrumental polarization, primary beam attenuation due to mispointing, and complex bandpass and receiver gains. The additive noise terms due to the troposphere and thermal noise are also modelled.","category":"page"},{"location":"instrumentmodels/#Gaussian-Process-Modelling","page":"Instrument Models","title":"Gaussian Process Modelling","text":"","category":"section"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"Anime uses Gaussian processes (GPs) to model time series. Gaussian processes are a generalization of the Gaussian probability distribution for functions (not just random variables). They define a probability distribution over possible functions that fit the data. A prior over the function space is encoded by the kernel function which takes two input data points and returns a measure of the covariance between them. Some kernel functions are manually implemented within Anime, with the squared exponential (SE) kernel (aka the Gaussian or the radial basis function (RBF) kernel) used as the default:","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"The SE kernel is defined as","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"k_SE(x-x) = sigma^2 e^-frac(x-x)^22rho^2","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"The variance sigma^2 is the scale factor and rho is the characteristic length scale that determines the smoothness of the function. More information on GPs can be found in standard references[GPML].","category":"page"},{"location":"instrumentmodels/#The-Earth's-Atmosphere","page":"Instrument Models","title":"The Earth's Atmosphere","text":"","category":"section"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"Starting from a few GHz and above, the lowest layer of Earth's atmosphere, the troposphere, comes into play and is a significant contributor to signal corruptions at mm and sub-mm wavelengths. In Anime we characterize it as consisting of a \"mean\" component and an additional rapidly varying turbulent component, following the python implementation in MEQSv2[IN2022].","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"The mean troposphere introduces smoothly varying time delays that result in phase slopes with frequency. The turbulence in the troposphere introduces rapidly-varying \"ad hoc\" delays. The troposphere also absorbs radiation due to molecular transitions (rotational transitions of H_2O and O_2). This, along with a frequency-dependent component to the opacity of the troposphere results in an attenuation of visibility amplitudes. In thermodynamic equilibrium, the troposphere also emits radiation which increases the system temperature.","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"The path length due to the wet (H_2O) and non-wet troposphere is computed using AATM[JRP2001] and is used to generate the delays due to mean troposphere. Delays due to turbulence are simulated using Brownian random walk. The elevation and transmission-dependent sky noise due to increased system temperature is accounted for in the noise budget.","category":"page"},{"location":"instrumentmodels/#Instrumental-Polarization","page":"Instrument Models","title":"Instrumental Polarization","text":"","category":"section"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"While the two polarization feeds on an antenna nominally measure orthogonal polarization states of the electromagnetic wave, mechanical/electronic imperfections in the signal path both feeds to be receptive to a small fraction of the other polarization state. In addition, the mount type of any azimuthally mounted telescope causes the feeds to rotate with respect to the sky which needs to be corrected for. These corrections together constitute the instrumental contribution to the polarization state of the recorded signal.","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"These effects are captured using the P-Jones (parallactic angle rotation) and D-Jones (polarization leakage) matrices given by[Hales2017]","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"P_p = beginpmatrix mathrme^-jchi__p  0  0  mathrme^jchi__p endpmatrix","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"and","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"D_p = beginpmatrix 1  d_pR  -d_pL  1 endpmatrix ","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"The observed visibilities are given by","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"mathbfV = (P_p^H) D_p (P_p) mathbfV_rm sky (P_q^H) D_q^H (P_q)","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"where","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"P_p^H D_p P_p = beginpmatrix 1  exp(2jchi_p)d_p^R  exp(-2jchi_p)d_p^L  1endpmatrix ","category":"page"},{"location":"instrumentmodels/#Primary-Beams","page":"Instrument Models","title":"Primary Beams","text":"","category":"section"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"The primary beams of participating stations determine the Field-of-View (FoV) of the observation. Several factors cause antennas to mispoint and modify its gain response, attenuating the measured visibility amplitudes, mathbfV_pq. At mm-wavelengths even small errors in antenna pointing can cause significant attenuation.","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"The rms pointing error per station mathcalP_rm rms values supplied by the user depend on site characteristics determined based on empirical measurements. The set of correlated per scan pointing offsets (rho_p) per pointing interval is obtained using GP, with mathcalP_rm rms as the scale parameter and the scan length as the characteristic length. A Gaussian primary beam profile is then used to model the primary beamshapes of the antennas, which is an acceptable approximation at the few hundreds of muas FoV that we are interested in for mm-VLBI.","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"E_p = mathrme^Bigg( -frac12 Biggfracrho_p(mathcalP_rm FWHM p2sqrt2ln 2)Bigg^2 Bigg)","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"where","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"rho_p = sqrtdelta l_p^2 + delta m_p^2","category":"page"},{"location":"instrumentmodels/#Bandpass-and-Receiver-Gains","page":"Instrument Models","title":"Bandpass and Receiver Gains","text":"","category":"section"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"The generic receiver gain matrix can have both a time-varying and a frequency-varying component. The frequency-dependent component (the B-Jones matrix), aims to capture the variations in the amplitude and phase of the measured correlation coefficients across the bandwidth. Representative complex bandpass gains are used to spline interpolate over the entire frequency range independently for the two polarization feeds to construct the B-Jones terms.","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"The time-dependent gain matrix (often just referred to as G-Jones matrix) per station is generated using GP, with representative station-based scale parameters and the characteristic length set to the scan length to ensure smooth variation of gains over the duration of a scan. The amplitudes and phases of these terms are generated with different smoothness scales to capture the statistical properties of receiver gain evolution over time in real observations.","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"Both terms are modelled using diagonal 2 x 2 Jones terms, assuming that the polarization basis of the gain matrices is the same as that of the visibilities. Currently, the basis in which complex visibilities are represented is the default and only option in which to represent the basis of the gain matrices.","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"G_p(t) = beginpmatrix g_pR(t)  0  0  g_pL(t) endpmatrix B_p(nu) = beginpmatrix b_pR(nu)  0  0  b_pL(nu) endpmatrix","category":"page"},{"location":"instrumentmodels/#Noise-Components","page":"Instrument Models","title":"Noise Components","text":"","category":"section"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"Apart from the sky noise contribution mentioned earlier, a receiver thermal noise model is also included in the noise budget. Station-based SEFD values are used to determine the per-visibility rms noise, sigma_th_pq:","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"sigma_th_pq = frac1eta sqrtfracmathrmSEFD_p mathrmSEFD_q2Delta nu tau","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"where A_mathrm e denotes the effective area of the telescope and eta comprises any relevant efficiency terms, such as the antenna aperture efficiency, eta_rm ap, and the correlator efficiency, eta_rm corr, Deltanu is the bandwidth and tau the integration time. For standard 2-bit quantization, eta is set to 0.88. The SEFD itself is defined as","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"mathrmSEFD = frac2 k_mathrm B T_mathrmsyseta_mathrmant A_mathrm e","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"where eta_mathrmant is the antenna efficiency and A_mathrm e is the effective area of the antenna.","category":"page"},{"location":"instrumentmodels/#References","page":"Instrument Models","title":"References","text":"","category":"section"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"[TMS]: Thompson A.R., Moran J.M., Swenson Jr. G.W. Interferometry and Synthesis in Radio Astronomy (2017) Springer","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"[HBS]: Hamaker J.P., Bregman J.D., Sault R.J. Understanding radio polarimetry I (1996) A&AS","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"[OMS]: Smirnov O.M. Revisiting the radio interferometry measurement equation I (2011) A&A","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"[GPML]: Rasmussen C.E., and Williams C. Gaussian Processes for Machine Learning MIT","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"[IN2022]: Natarajan I. et al. MeqSilhouette v2: spectrally resolved polarimetric synthetic data generation for EHT (2022) MNRAS","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"[JRP2001]: Pardo J.R., et al. Atmospheric transmission at microwaves (ATM): an improved model for mm/submm applications (2001) IEEE Xplore","category":"page"},{"location":"instrumentmodels/","page":"Instrument Models","title":"Instrument Models","text":"[Hales2017]: Hales C., Calibration Errors in Interferometric Radio Polarimetry (2017) The Astronomical Journal","category":"page"}]
}
